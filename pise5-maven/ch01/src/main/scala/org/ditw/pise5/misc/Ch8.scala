package org.ditw.pise5.misc

import scala.annotation.tailrec

object Ch8 {
  private def trace(v: Any): Unit =
    println(s"v = $v, type: ${v.getClass.getSimpleName}")

  // 1. method
  //  def convertToOrdinal(num: Int): String = {
  //    num match {
  //      case 1 => "first"
  //      case 2 => "second"
  //      case 3 => "third"
  //      case _ => num + "th"
  //    }
  //  }
  //
  //  case class NumWrapper(num: Int) {
  //    def toOridinal: String = convertToOrdinal(num)
  //  }

  // 2. local function: function within function
  //  def convertToOrdinalFixed(num: Int): String = {
  //    def lastDigitToPostfix(n: Int): String = {
  //      val d = n / 10
  //      val rem = n % 10
  //      if (d > 1) {
  //        rem match {
  //          case 1 => "st"
  //          case 2 => "nd"
  //          case 3 => "rd"
  //          case _ => "th"
  //        }
  //      } else {
  //        "th"
  //      }
  //    }
  //
  //    num match {
  //      case 1 => "first"
  //      case 2 => "second"
  //      case 3 => "third"
  //      case _ => num + lastDigitToOrdinalPostfix(num)
  //    }
  //  }
  //
  //  println(convertToOrdinalFixed(1))
  //  println(convertToOrdinalFixed(11))
  //  println(convertToOrdinalFixed(21))
  //
  //  println(convertToOrdinalFixed(4))
  //  println(convertToOrdinalFixed(14))
  //  println(convertToOrdinalFixed(24))

  // 3 first-class functions
    // Every function value is an instance of one of several FunctionN traits in package scala,
    //   such as Function0 for functions with no parameters, Function1 for functions with one
    //   parameter, and so on.
  def convertToOrdinalFixed(num: Int): String = {
    val lastDigitToOrdinalPostfix =
    // function literal: definition
    (n: Int) => {
      val d = n / 10
      val rem = n % 10
      if (d > 1) {
        rem match {
          case 1 => "st"
          case 2 => "nd"
          case 3 => "rd"
          case _ => "th"
        }
      } else {
        "th"
      }
    }

    num match {
      case 1 => "first"
      case 2 => "second"
      case 3 => "third"
      case _ => num + lastDigitToOrdinalPostfix(num) // function value: instantiated at runtime
    }
  }

  // 3.1 .foreach .filter
  //  val numList = List(1, 3, 6, 11, 21)
  //  val printFn = (n: Int) => println(convertToOrdinalFixed(n))
  //  numList.foreach(printFn)
  //  val isEvenFn = (n: Int) => n % 2 == 0
  //  val evenNumList = numList.filter(isEvenFn)
  //  println()
  //  println(evenNumList)

  // 4. short forms
  //  val numList = List(1, 3, 6, 11, 21)
  //  //  target typing
  //  val evenNumList = numList.filter(n => n % 2 == 0)
  //  println(evenNumList)

  // 5. placeholder syntax
  //  val numList = List(1, 3, 6, 11, 21)
  //  val evenNumList = numList.filter(_ % 2 == 0)
  //  println(evenNumList)
  //
  //  val sum: Int = numList.fold(0)(_ + _)
  //  println(sum)

  // 6. partially applied function
  //  "apply the function to the arguments"
  def sumMd(a: Int, b: Int, c: Int): Int = a + b + c
  //  // Hereâ€™s what just happened: The variable named a refers to a function value
  //  //  object. This function value is an instance of a class generated automatically
  //  //  by the Scala compiler from sum(_, _, _), the partially applied function
  //  //  expression. The class generated by the compiler has an apply method that
  //  //  takes three arguments.
  //  val sum3 = sumMd(_, _, _)
  //  val sum3Full = new Function3[Int, Int, Int, Int] {
  //    override def apply(v1: Int, v2: Int, v3: Int): Int = sumMd(v1, v2, v3)
  //  }
  //  println(sum3Full(1, 3, 4))

  // 6.1 apply some of the required arguments
  //  val sum1 = sumMd(1, _, 4)
  //  val sum1Full = new Function1[Int, Int] {
  //    override def apply(v1: Int): Int = 1 + v1 + 4
  //  }
  //  println(sum1(2))
  //  println(sum1(3))
  //  println(sum1Full(2))
  //  println(sum1Full(3))
  //
  //  def testMd(numOfCores: Int, iterations: Int): Unit =
  //    println(s"Running test with $numOfCores cores and $iterations iterations...")
  //  val testIterationsWith4Cores = testMd(4, _)
  //  val testCoresWith100Iterations = testMd(_, 100)
  //
  //  (1 to 4).foreach(factor => testIterationsWith4Cores(factor*20))
  //
  //  2.to(8, 2).foreach(testCoresWith100Iterations)

  // 6.2 Eta-expansion
  //   https://docs.scala-lang.org/scala3/book/fun-eta-expansion.html
  //   https://docs.scala-lang.org/scala3/reference/changed-features/eta-expansion-spec.html#
  //  def isEven(n: Int): Boolean = n % 2 == 0
  //  List(1, 3, 5, 4).filter(isEven)

  // 7. closures
  //  var more = 10
  //  val closure1 = (x: Int) => x + more
  //  println(closure1(2))
  //
  //  more = 20
  //  println(closure1(2))

  // 7.1
  // In computer science, a closure (also lexical closure or function closure) is a function together
  //   with a referencing environment for the non-local variables of that function. A closure allows
  //   a function to access variables outside its immediate lexical scope.
  //  def genClosure(seed: Int): Int => Int = {
  //    val more = seed*10
  //    x => {
  //      x + more
  //    }
  //  }
  //
  //  val closure2 = genClosure(10)
  //  println(closure2(2))

  // 8 special function call forms
  // 8.1 repeated parameters
  //  def sumx(values: Int*) = {
  ////    trace(values)
  //    values.sum
  //  }
  //  println(sumx(1, 2, 3))
  //
  //  val ints = List(1, 2, 3)
  //  println(sumx(ints*))
  //  println(sumx(ints: _*))

  // 8.2 named argument
  // 8.3 default arguments

  // 9 SAM type: single abstract method
  //  trait TFilter {
  //    def filter(t: Int): Boolean
  //  }
  //
  //  def filter(input: Iterable[Int], f: TFilter) = {
  //    input.filter(f.filter)
  //  }
  //
  //  val evenList = filter(
  //    List(1, 3, 4),
  //    v => v % 2 == 0
  //  )
  //  println(evenList)

  // 10 tail recursion
//  def fact(n: Int): BigInt =
//    if (n == 0) 1
//    else n * fact(n-1)
//  println(fact(100000))

//  @tailrec
//  def fact1(n: Int, acc: BigInt): BigInt =
//    if (n == 0) acc
//    else fact1(n-1, acc*n)
//  println(fact1(100000, 1))

  def main(args: Array[String]): Unit = { }

}
